<html>
  <head>
    <title>Grafy</title>
    <script src="../src/sigma.core.js"></script>
    <script src="../src/conrad.js"></script>
    <script src="../src/utils/sigma.utils.js"></script>
    <script src="../src/utils/sigma.polyfills.js"></script>
    <script src="../src/sigma.settings.js"></script>
    <script src="../src/classes/sigma.classes.dispatcher.js"></script>
    <script src="../src/classes/sigma.classes.configurable.js"></script>
    <script src="../src/classes/sigma.classes.graph.js"></script>
    <script src="../src/classes/sigma.classes.camera.js"></script>
    <script src="../src/classes/sigma.classes.quad.js"></script>
    <script src="../src/classes/sigma.classes.edgequad.js"></script>
    <script src="../src/captors/sigma.captors.mouse.js"></script>
    <script src="../src/captors/sigma.captors.touch.js"></script>
    <script src="../src/renderers/sigma.renderers.canvas.js"></script>
    <script src="../src/renderers/sigma.renderers.webgl.js"></script>
    <script src="../src/renderers/sigma.renderers.svg.js"></script>
    <script src="../src/renderers/sigma.renderers.def.js"></script>
    <script src="../build/plugins/sigma.renderers.edgeLabels.min.js"></script>
    <script src="../src/renderers/webgl/sigma.webgl.nodes.def.js"></script>
    <script src="../src/renderers/webgl/sigma.webgl.nodes.fast.js"></script>
    <script src="../src/renderers/webgl/sigma.webgl.edges.def.js"></script>
    <script src="../src/renderers/webgl/sigma.webgl.edges.fast.js"></script>
    <script src="../src/renderers/webgl/sigma.webgl.edges.arrow.js"></script>
    <script src="../src/renderers/canvas/sigma.canvas.labels.def.js"></script>
    <script src="../src/renderers/canvas/sigma.canvas.hovers.def.js"></script>
    <script src="../src/renderers/canvas/sigma.canvas.nodes.def.js"></script>
    <script src="../src/renderers/canvas/sigma.canvas.edges.def.js"></script>
    <script src="../src/renderers/canvas/sigma.canvas.edges.curve.js"></script>
    <script src="../src/renderers/canvas/sigma.canvas.edges.arrow.js"></script>
    <script src="../src/renderers/canvas/sigma.canvas.edges.curvedArrow.js"></script>
    <script src="../src/renderers/canvas/sigma.canvas.edgehovers.def.js"></script>
    <script src="../src/renderers/canvas/sigma.canvas.edgehovers.curve.js"></script>
    <script src="../src/renderers/canvas/sigma.canvas.edgehovers.arrow.js"></script>
    <script src="../src/renderers/canvas/sigma.canvas.edgehovers.curvedArrow.js"></script>
    <script src="../src/renderers/canvas/sigma.canvas.extremities.def.js"></script>
    <script src="../src/renderers/svg/sigma.svg.utils.js"></script>
    <script src="../src/renderers/svg/sigma.svg.nodes.def.js"></script>
    <script src="../src/renderers/svg/sigma.svg.edges.def.js"></script>
    <script src="../src/renderers/svg/sigma.svg.edges.curve.js"></script>
    <script src="../src/renderers/svg/sigma.svg.labels.def.js"></script>
    <script src="../src/renderers/svg/sigma.svg.hovers.def.js"></script>
    <script src="../src/middlewares/sigma.middlewares.rescale.js"></script>
    <script src="../src/middlewares/sigma.middlewares.copy.js"></script>
    <script src="../src/misc/sigma.misc.animation.js"></script>
    <script src="../src/misc/sigma.misc.bindEvents.js"></script>
    <script src="../src/misc/sigma.misc.bindDOMEvents.js"></script>
    <script src="../src/misc/sigma.misc.drawHovers.js"></script>

    <script src="../plugins/sigma.renderers.parallelEdges/utils.js"></script>
    <script src="../plugins/sigma.renderers.parallelEdges/sigma.canvas.edges.curve.js"></script>
    <script src="../plugins/sigma.renderers.parallelEdges/sigma.canvas.edges.curvedArrow.js"></script>
    <script src="../plugins/sigma.renderers.parallelEdges/sigma.canvas.edgehovers.curve.js"></script>
    <script src="../plugins/sigma.renderers.parallelEdges/sigma.canvas.edgehovers.curvedArrow.js"></script>
    <script src="../plugins/sigma.renderers.edgeLabels/settings.js"></script>
    <script src="../plugins/sigma.renderers.edgeLabels/sigma.canvas.edges.labels.def.js"></script>
    <script src="../plugins/sigma.renderers.edgeLabels/sigma.canvas.edges.labels.curve.js"></script>
    <script src="../plugins/sigma.renderers.edgeLabels/sigma.canvas.edges.labels.curvedArrow.js"></script>
    <style>
      html {
        height: 100%;
      }
      body {
        height: 100%;
      }
      #sigma-container {
        width: 100%;
        height: 100%;
        background-color: #e1e1e1;
      }
    </style>
  </head>
  <body>
    <div class="input">
      <textarea
        name="m1"
        id="m1"
        cols="30"
        rows="4"
        placeholder="Macierz sasiedztwa"
      >
[0,1,0,0,0,1,0];[1,0,1,0,0,1,1];[0,1,0,1,1,0,1];[0,0,1,0,1,0,0];[0,0,1,1,0,1,1];[1,1,0,0,1,0,1];[0,1,1,0,1,1,0]</textarea
      >
      <button onclick="MatrixS()">Rysuj</button>
      <textarea
        name="m2"
        id="m2"
        cols="30"
        rows="4"
        placeholder="Macierz incydencji"
      >
[1,0,0,0,1,0,1,0,0,0];[1,1,0,0,0,1,0,1,0,0];[0,1,1,0,0,0,0,0,0,0];[0,0,1,1,0,1,0,0,1,0];[0,0,0,1,1,0,0,0,0,1];[0,0,0,0,0,0,1,1,1,1]</textarea
      >
      <button onclick="MatrixI()">Rysuj</button>
      <textarea
        name="m3"
        id="m3"
        cols="30"
        rows="4"
        placeholder="Lista sasiedztwa"
      >
0:1,3,4;1:0,2,4;2:1,3,4;3:0,2,4;4:0,1,2,3</textarea
      >
      <button onclick="MacS()">Rysuj</button>

      <div style="display: inline-block; position: absolute; top: 10;">
        <div style="display: flex; flex-direction: column; position: relative;">
          <div style="position: absolute; left: 250; top: -5;">
            <div id="hamilton-container"></div>
            <div id="euler-container"></div>
            <div id="crit-container"></div>
            <div id="color-container"></div>
            <div id="dfs-container"></div>
          </div>

          <button
            style="position: absolute; left: 180; top: 10;"
            onclick="drawG()"
          >
            Rysuj
          </button>

          <button onclick="addW()">
            Dodaj W
          </button>

          <input type="text" id="edge" name="edge" /><button onclick="addE()">
            Dodaj E
          </button>
        </div>
      </div>
    </div>

    <div id="sigma-container"></div>
    <script>
      var s = new sigma();
      var Nodecount = 0;
      var m = 0;
      function addW() {
        s.graph.addNode({
          id: `n${Nodecount}`,
          label: "W" + Nodecount,
          x: Math.random(),
          y: Math.random(),
          size: 1,
          color: "#666",
        });
        Nodecount++;
      }

      function addE() {
        var tex = document.querySelector("#edge").value.split(";");
        var src = tex[0];
        var trg = tex[1];
        s.graph.addEdge({
          id: `${m}`,
          source: `n${tex[0]}`,
          target: `n${tex[1]}`,
          size: 1,
          label: "E" + m,
          type: "curve",
          count: m,
        });
        m++;
      }
      function drawG() {
        g = {
          nodes: s.graph.nodes(),
          edges: s.graph.edges(),
        };
        s = new sigma({
          graph: g,
          renderer: {
            container: "sigma-container",
            type: "canvas",
          },
          settings: {
            edgeLabelSize: "proportional",
            defaultLabelSize: 15,
            defaultEdgeLabelSize: 15,
          },
        });

        m = 0;
        Nodecount = 0;
        var visited = [];
        var stos = [];
        spj = false;
        // SPOJNOSC
        var dict = new Object();
        s.graph.nodes().forEach((element) => {
          dict[element.id] = [];
        });
        s.graph.edges().forEach((element) => {
          dict[element.source].push(element.target);
          dict[element.target].push(element.source);
        });

        visited.push(s.graph.nodes()[0].id);
        spj = spoj(s.graph.nodes()[0].id, dict, visited, stos);
        document.querySelector("#dfs-container").innerHTML = `dfs: ${stos}`;
        // KRAWEDZ KRYTYCZNA

        s.kill();
        critable = [];

        s = new sigma({
          graph: g,
        });

        for (let i = 0; i < s.graph.edges().length; i++) {
          s.kill();
          s = new sigma({
            graph: g,
          });
          s.graph.dropEdge(s.graph.edges()[i].id);
          var visited = [];
          var stos = [];
          var dict = new Object();
          s.graph.nodes().forEach((element) => {
            dict[element.id] = [];
          });
          s.graph.edges().forEach((element) => {
            dict[element.source].push(element.target);
            dict[element.target].push(element.source);
          });
          visited.push(s.graph.nodes()[0].id);

          crit = spoj(s.graph.nodes()[0].id, dict, visited, stos);
          if (!crit) {
            critable.push(i);
          }
          s = new sigma({
            graph: g,
          });
        }

        document.querySelector(
          "#crit-container"
        ).innerHTML = `krytyczna ${critable.toString()}`;

        s.kill();

        // KOLOROWANIE
        s = new sigma({
          graph: g,
        });
        var dict = new Object();
        s.graph.nodes().forEach((element) => {
          dict[element.id] = [];
        });
        s.graph.edges().forEach((element) => {
          dict[element.source].push(element.target.slice(1, 2));
          dict[element.target].push(element.source.slice(1, 2));
        });
        colors = new Object();
        colorsTable = [];
        ct = 0;
        s.graph.nodes().forEach((element) => {
          colors[parseInt(element.id.slice(1, 2))] = [];
        });
        s.graph.nodes().forEach((element) => {
          colorsTable.push(ct);
          ct++;
        });

        colors[0] = 0;
        var visCol = [];
        for (let i = 1; i < s.graph.nodes().length; i++) {
          dict[`n${i}`].forEach((e) => {
            if (colorsTable.includes(colors[parseInt(e)])) {
              visCol.push(colors[parseInt(e)]);
            }
          });
          var arr3 = colorsTable.filter(function (obj) {
            return visCol.indexOf(obj) == -1;
          });
          colors[i] = arr3[0];
          visCol = [];
        }

        document.querySelector(
          "#color-container"
        ).innerHTML = `Kolor${JSON.stringify(colors)}`;

        s.kill();

        // Kolor last
        s = new sigma({
          graph: g,
        });
        var dict = new Object();
        s.graph.nodes().forEach((element) => {
          dict[element.id] = [];
        });
        s.graph.edges().forEach((element) => {
          dict[element.source].push(element.target.slice(1, 2));
          dict[element.target].push(element.source.slice(1, 2));
        });
        colarr = [];
        console.log(dict);
        for (let i = s.graph.nodes().length - 1; i > -1; i--) {
          dict[`n${i}`];
          for (let j = 0; j < s.graph.nodes().length; j++) {
            if (dict[`n${j}`].length == i) {
              colarr.push(j);
            }
          }
        }

        colarr.forEach((element) => {
          colors[element] = [];
        });

        s.graph.nodes().forEach((element) => {
          colorsTable.push(ct);
          ct++;
        });
        var visCol = [];

        colarr.forEach((e) => {
          dict[`n${e}`].forEach((element) => {
            if (colorsTable.includes(colors[parseInt(element)])) {
              visCol.push(colors[parseInt(element)]);
            }
          });
          var arr3 = colorsTable.filter(function (obj) {
            return visCol.indexOf(obj) == -1;
          });
          colors[e] = arr3[0];
          visCol = [];
        });
        console.log("Kolory od ostatniego:");
        console.log(colarr);
        console.log(colors);

        s.kill();

        // Random kolor
        s = new sigma({
          graph: g,
        });
        var dict = new Object();
        s.graph.nodes().forEach((element) => {
          dict[element.id] = [];
        });
        s.graph.edges().forEach((element) => {
          dict[element.source].push(element.target.slice(1, 2));
          dict[element.target].push(element.source.slice(1, 2));
        });
        colors = new Object();
        colorsTable = [];
        ct = 0;
        colarr = [];
        s.graph.nodes().forEach((element) => {
          colarr.push(parseInt(element.id.slice(1, 2)));
        });

        function shuffle(array) {
          var currentIndex = array.length,
            temporaryValue,
            randomIndex;

          // While there remain elements to shuffle...
          while (0 !== currentIndex) {
            // Pick a remaining element...
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;

            // And swap it with the current element.
            temporaryValue = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temporaryValue;
          }

          return array;
        }

        colarr = shuffle(colarr);

        colarr.forEach((element) => {
          colors[element] = [];
        });

        s.graph.nodes().forEach((element) => {
          colorsTable.push(ct);
          ct++;
        });
        var visCol = [];

        colarr.forEach((e) => {
          dict[`n${e}`].forEach((element) => {
            if (colorsTable.includes(colors[parseInt(element)])) {
              visCol.push(colors[parseInt(element)]);
            }
          });
          var arr3 = colorsTable.filter(function (obj) {
            return visCol.indexOf(obj) == -1;
          });
          colors[e] = arr3[0];
          visCol = [];
        });
        console.log("Kolory random:");
        console.log(colarr);
        console.log(colors);

        s.kill();

        // HAMILTON
        s = new sigma({
          graph: g,
        });
        if (spj) {
          var dict = new Object();
          visited = [];
          s.graph.nodes().forEach((element) => {
            dict[element.id] = [];
          });
          s.graph.edges().forEach((element) => {
            dict[element.source].push(element.target);
            dict[element.target].push(element.source);
          });
          hamilton = [];
          dead = new Object();
          s.graph.nodes().forEach((element) => {
            dead[parseInt(element.id.slice(1, 2))] = [];
          });
          visited.push(s.graph.nodes()[0].id);
          for (let i = 0; i < s.graph.nodes().length; i++) {
            hamilton.push(0);
          }

          ham(1, dict, hamilton, dead);

          if (hamilton[0] == 0 && hamilton[1] == 0) {
            document.querySelector(
              "#hamilton-container"
            ).innerHTML = `Brak cyklu hamiltona`;
          } else {
            document.querySelector(
              "#hamilton-container"
            ).innerHTML = `hamilton:${hamilton}`;
          }
        }
        // EULER
        s.kill();

        s = new sigma({
          graph: g,
          renderer: {
            container: "sigma-container",
            type: "canvas",
          },
          settings: {
            edgeLabelSize: "proportional",
            defaultLabelSize: 20,
            defaultEdgeLabelSize: 20,
          },
        });
        if (spj) {
          var eul = true;
          s.graph.nodes().forEach((e) => {
            if (s.graph.degree(e.id) % 2 !== 0) {
              eul = false;
            }
          });
          if (eul === false) {
            document.querySelector(
              "#euler-container"
            ).innerHTML = `Euler: Brak`;
          } else {
            var dict = new Object();
            visited = [];
            stos = [];
            s.graph.nodes().forEach((element) => {
              dict[element.id] = [];
            });
            s.graph.edges().forEach((element) => {
              dict[element.source].push(element.target);
              dict[element.target].push(element.source);
            });
            visited.push(s.graph.nodes()[0].id);
            dfs(s.graph.nodes()[0].id, dict, visited, stos);
            document.querySelector(
              "#euler-container"
            ).innerHTML = `Euler:${stos}`;
          }
        } else {
          document.querySelector(
            "#hamilton-container"
          ).innerHTML = `Cykl nie jest spojny`;
        }
        s.kill();
        s = new sigma({
          graph: g,
          renderer: {
            container: "sigma-container",
            type: "canvas",
          },
          settings: {
            edgeLabelSize: "proportional",
            defaultLabelSize: 20,
            defaultEdgeLabelSize: 20,
          },
        });
      }

      function MatrixS() {
        var i,
          g = {
            nodes: [],
            edges: [],
          };
        var m1str = document.querySelector("#m1").value;
        var res = m1str.split(";");
        var table = [res.length];
        res.forEach((e, i) => {
          var patt1 = /[0-9]/g;
          var result = e.match(patt1);
          var tab = [];
          for (let j = 0; j < result.length; j++) {
            tab.push(parseInt(result[j]));
          }
          table[i] = tab;
        });

        var edgeNum = 0;
        var z = 0;
        table.forEach((e, i) => {
          for (j = i; j < e.length; j++) {
            if (e[j] != 0) {
              if (e[j] > 1) {
                for (let h = 0; h < e[j]; h++) {
                  g.edges.push({
                    id: "e" + z,
                    source: "n" + i,
                    target: "n" + j,
                    size: 1,
                    label: "E" + z,
                    type: "curve",
                    count: z,
                  });
                  z++;
                }
              } else {
                g.edges.push({
                  id: "e" + z,
                  source: "n" + i,
                  target: "n" + j,
                  size: 1,
                  label: "E" + z,
                  type: "curve",
                  count: z,
                });
                z++;
              }
            }

            edgeNum += e[j];
          }
        });

        s.kill();
        var N = table.length;
        var E = edgeNum;

        for (i = 0; i < N; i++)
          g.nodes.push({
            id: "n" + i,
            label: "W" + i,
            x: Math.random(),
            y: Math.random(),
            size: 1,
            color: "#666",
          });

        s = new sigma({
          graph: g,
          renderer: {
            container: "sigma-container",
            type: "canvas",
          },
          settings: {
            edgeLabelSize: "proportional",
            defaultLabelSize: 15,
            defaultEdgeLabelSize: 15,
          },
        });
        var visited = [];
        var stos = [];
        spj = false;
        // SPOJNOSC
        var dict = new Object();
        s.graph.nodes().forEach((element) => {
          dict[element.id] = [];
        });
        s.graph.edges().forEach((element) => {
          dict[element.source].push(element.target);
          dict[element.target].push(element.source);
        });

        visited.push(s.graph.nodes()[0].id);
        spj = spoj(s.graph.nodes()[0].id, dict, visited, stos);
        document.querySelector("#dfs-container").innerHTML = `dfs: ${stos}`;
        // KRAWEDZ KRYTYCZNA

        s.kill();
        critable = [];

        s = new sigma({
          graph: g,
        });

        for (let i = 0; i < s.graph.edges().length; i++) {
          s.kill();
          s = new sigma({
            graph: g,
          });
          s.graph.dropEdge(s.graph.edges()[i].id);
          var visited = [];
          var stos = [];
          var dict = new Object();
          s.graph.nodes().forEach((element) => {
            dict[element.id] = [];
          });
          s.graph.edges().forEach((element) => {
            dict[element.source].push(element.target);
            dict[element.target].push(element.source);
          });
          visited.push(s.graph.nodes()[0].id);

          crit = spoj(s.graph.nodes()[0].id, dict, visited, stos);
          if (!crit) {
            critable.push(i);
          }
          s = new sigma({
            graph: g,
          });
        }

        document.querySelector(
          "#crit-container"
        ).innerHTML = `krytyczna ${critable.toString()}`;

        s.kill();

        // KOLOROWANIE
        s = new sigma({
          graph: g,
        });
        var dict = new Object();
        s.graph.nodes().forEach((element) => {
          dict[element.id] = [];
        });
        s.graph.edges().forEach((element) => {
          dict[element.source].push(element.target.slice(1, 2));
          dict[element.target].push(element.source.slice(1, 2));
        });
        colors = new Object();
        colorsTable = [];
        ct = 0;
        s.graph.nodes().forEach((element) => {
          colors[parseInt(element.id.slice(1, 2))] = [];
        });
        s.graph.nodes().forEach((element) => {
          colorsTable.push(ct);
          ct++;
        });

        colors[0] = 0;
        var visCol = [];
        for (let i = 1; i < s.graph.nodes().length; i++) {
          dict[`n${i}`].forEach((e) => {
            if (colorsTable.includes(colors[parseInt(e)])) {
              visCol.push(colors[parseInt(e)]);
            }
          });
          var arr3 = colorsTable.filter(function (obj) {
            return visCol.indexOf(obj) == -1;
          });
          colors[i] = arr3[0];
          visCol = [];
        }

        document.querySelector(
          "#color-container"
        ).innerHTML = `Kolor${JSON.stringify(colors)}`;

        s.kill();

        // Kolor last
        s = new sigma({
          graph: g,
        });
        var dict = new Object();
        s.graph.nodes().forEach((element) => {
          dict[element.id] = [];
        });
        s.graph.edges().forEach((element) => {
          dict[element.source].push(element.target.slice(1, 2));
          dict[element.target].push(element.source.slice(1, 2));
        });
        colarr = [];
        console.log(dict);
        for (let i = s.graph.nodes().length - 1; i > -1; i--) {
          dict[`n${i}`];
          for (let j = 0; j < s.graph.nodes().length; j++) {
            if (dict[`n${j}`].length == i) {
              colarr.push(j);
            }
          }
        }

        colarr.forEach((element) => {
          colors[element] = [];
        });

        s.graph.nodes().forEach((element) => {
          colorsTable.push(ct);
          ct++;
        });
        var visCol = [];

        colarr.forEach((e) => {
          dict[`n${e}`].forEach((element) => {
            if (colorsTable.includes(colors[parseInt(element)])) {
              visCol.push(colors[parseInt(element)]);
            }
          });
          var arr3 = colorsTable.filter(function (obj) {
            return visCol.indexOf(obj) == -1;
          });
          colors[e] = arr3[0];
          visCol = [];
        });
        console.log("Kolory od ostatniego:");
        console.log(colarr);
        console.log(colors);

        s.kill();

        // Random kolor
        s = new sigma({
          graph: g,
        });
        var dict = new Object();
        s.graph.nodes().forEach((element) => {
          dict[element.id] = [];
        });
        s.graph.edges().forEach((element) => {
          dict[element.source].push(element.target.slice(1, 2));
          dict[element.target].push(element.source.slice(1, 2));
        });
        colors = new Object();
        colorsTable = [];
        ct = 0;
        colarr = [];
        s.graph.nodes().forEach((element) => {
          colarr.push(parseInt(element.id.slice(1, 2)));
        });

        function shuffle(array) {
          var currentIndex = array.length,
            temporaryValue,
            randomIndex;

          // While there remain elements to shuffle...
          while (0 !== currentIndex) {
            // Pick a remaining element...
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;

            // And swap it with the current element.
            temporaryValue = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temporaryValue;
          }

          return array;
        }

        colarr = shuffle(colarr);

        colarr.forEach((element) => {
          colors[element] = [];
        });

        s.graph.nodes().forEach((element) => {
          colorsTable.push(ct);
          ct++;
        });
        var visCol = [];

        colarr.forEach((e) => {
          dict[`n${e}`].forEach((element) => {
            if (colorsTable.includes(colors[parseInt(element)])) {
              visCol.push(colors[parseInt(element)]);
            }
          });
          var arr3 = colorsTable.filter(function (obj) {
            return visCol.indexOf(obj) == -1;
          });
          colors[e] = arr3[0];
          visCol = [];
        });
        console.log("Kolory random:");
        console.log(colarr);
        console.log(colors);

        s.kill();

        // HAMILTON
        s = new sigma({
          graph: g,
        });
        if (spj) {
          var dict = new Object();
          visited = [];
          s.graph.nodes().forEach((element) => {
            dict[element.id] = [];
          });
          s.graph.edges().forEach((element) => {
            dict[element.source].push(element.target);
            dict[element.target].push(element.source);
          });
          hamilton = [];
          dead = new Object();
          s.graph.nodes().forEach((element) => {
            dead[parseInt(element.id.slice(1, 2))] = [];
          });
          visited.push(s.graph.nodes()[0].id);
          for (let i = 0; i < s.graph.nodes().length; i++) {
            hamilton.push(0);
          }

          ham(1, dict, hamilton, dead);

          if (hamilton[0] == 0 && hamilton[1] == 0) {
            document.querySelector(
              "#hamilton-container"
            ).innerHTML = `Brak cyklu hamiltona`;
          } else {
            document.querySelector(
              "#hamilton-container"
            ).innerHTML = `hamilton:${hamilton}`;
          }
        }
        // EULER
        s.kill();

        s = new sigma({
          graph: g,
          renderer: {
            container: "sigma-container",
            type: "canvas",
          },
          settings: {
            edgeLabelSize: "proportional",
            defaultLabelSize: 20,
            defaultEdgeLabelSize: 20,
          },
        });
        if (spj) {
          var eul = true;
          s.graph.nodes().forEach((e) => {
            if (s.graph.degree(e.id) % 2 !== 0) {
              eul = false;
            }
          });
          if (eul === false) {
            document.querySelector(
              "#euler-container"
            ).innerHTML = `Euler: Brak`;
          } else {
            var dict = new Object();
            visited = [];
            stos = [];
            s.graph.nodes().forEach((element) => {
              dict[element.id] = [];
            });
            s.graph.edges().forEach((element) => {
              dict[element.source].push(element.target);
              dict[element.target].push(element.source);
            });
            visited.push(s.graph.nodes()[0].id);
            dfs(s.graph.nodes()[0].id, dict, visited, stos);
            document.querySelector(
              "#euler-container"
            ).innerHTML = `Euler:${stos}`;
          }
        } else {
          document.querySelector(
            "#hamilton-container"
          ).innerHTML = `Cykl nie jest spojny`;
        }
        s.kill();
        s = new sigma({
          graph: g,
          renderer: {
            container: "sigma-container",
            type: "canvas",
          },
          settings: {
            edgeLabelSize: "proportional",
            defaultLabelSize: 20,
            defaultEdgeLabelSize: 20,
          },
        });
      }
      function MatrixI() {
        var i,
          g = {
            nodes: [],
            edges: [],
          };
        var m2str = document.querySelector("#m2").value;
        var res = m2str.split(";");
        var table = [res.length];
        res.forEach((e, i) => {
          var patt1 = /[0-9]/g;
          var result = e.match(patt1);
          var tab = [];
          for (let j = 0; j < result.length; j++) {
            tab.push(parseInt(result[j]));
          }
          table[i] = tab;
        });

        var temp,
          z = 0;
        for (let i = 0; i < table[0].length; i++) {
          temp = undefined;
          for (let j = 0; j < table.length; j++) {
            if (table[j][i] === 1) {
              if (temp !== j && temp !== undefined) {
                g.edges.push({
                  id: "e" + z,
                  source: "n" + temp,
                  target: "n" + j,
                  size: 1,
                  label: "E" + z,
                  type: "curve",
                  count: z,
                });
                z++;
              } else {
                temp = j;
              }
            }
          }
        }
        s.kill();

        var N = table.length;
        var E = table[0].length;
        // Generate a random graph:
        for (i = 0; i < N; i++)
          g.nodes.push({
            id: "n" + i,
            label: "W" + i,
            x: Math.random(),
            y: Math.random(),
            size: 1,
            color: "#666",
          });

        s = new sigma({
          graph: g,
          renderer: {
            container: "sigma-container",
            type: "canvas",
          },
          settings: {
            edgeLabelSize: "proportional",
            defaultLabelSize: 15,
            defaultEdgeLabelSize: 15,
          },
        });
        var visited = [];
        var stos = [];
        spj = false;
        // SPOJNOSC
        var dict = new Object();
        s.graph.nodes().forEach((element) => {
          dict[element.id] = [];
        });
        s.graph.edges().forEach((element) => {
          dict[element.source].push(element.target);
          dict[element.target].push(element.source);
        });

        visited.push(s.graph.nodes()[0].id);
        spj = spoj(s.graph.nodes()[0].id, dict, visited, stos);
        document.querySelector("#dfs-container").innerHTML = `dfs: ${stos}`;
        // KRAWEDZ KRYTYCZNA

        s.kill();
        critable = [];

        s = new sigma({
          graph: g,
        });

        for (let i = 0; i < s.graph.edges().length; i++) {
          s.kill();
          s = new sigma({
            graph: g,
          });
          s.graph.dropEdge(s.graph.edges()[i].id);
          var visited = [];
          var stos = [];
          var dict = new Object();
          s.graph.nodes().forEach((element) => {
            dict[element.id] = [];
          });
          s.graph.edges().forEach((element) => {
            dict[element.source].push(element.target);
            dict[element.target].push(element.source);
          });
          visited.push(s.graph.nodes()[0].id);

          crit = spoj(s.graph.nodes()[0].id, dict, visited, stos);
          if (!crit) {
            critable.push(i);
          }
          s = new sigma({
            graph: g,
          });
        }

        document.querySelector(
          "#crit-container"
        ).innerHTML = `krytyczna ${critable.toString()}`;

        s.kill();

        // KOLOROWANIE
        s = new sigma({
          graph: g,
        });
        var dict = new Object();
        s.graph.nodes().forEach((element) => {
          dict[element.id] = [];
        });
        s.graph.edges().forEach((element) => {
          dict[element.source].push(element.target.slice(1, 2));
          dict[element.target].push(element.source.slice(1, 2));
        });
        colors = new Object();
        colorsTable = [];
        ct = 0;
        s.graph.nodes().forEach((element) => {
          colors[parseInt(element.id.slice(1, 2))] = [];
        });
        s.graph.nodes().forEach((element) => {
          colorsTable.push(ct);
          ct++;
        });

        colors[0] = 0;
        var visCol = [];
        for (let i = 1; i < s.graph.nodes().length; i++) {
          dict[`n${i}`].forEach((e) => {
            if (colorsTable.includes(colors[parseInt(e)])) {
              visCol.push(colors[parseInt(e)]);
            }
          });
          var arr3 = colorsTable.filter(function (obj) {
            return visCol.indexOf(obj) == -1;
          });
          colors[i] = arr3[0];
          visCol = [];
        }

        document.querySelector(
          "#color-container"
        ).innerHTML = `Kolor${JSON.stringify(colors)}`;

        s.kill();

        // Kolor last
        s = new sigma({
          graph: g,
        });
        var dict = new Object();
        s.graph.nodes().forEach((element) => {
          dict[element.id] = [];
        });
        s.graph.edges().forEach((element) => {
          dict[element.source].push(element.target.slice(1, 2));
          dict[element.target].push(element.source.slice(1, 2));
        });
        colarr = [];
        console.log(dict);
        for (let i = s.graph.nodes().length - 1; i > -1; i--) {
          dict[`n${i}`];
          for (let j = 0; j < s.graph.nodes().length; j++) {
            if (dict[`n${j}`].length == i) {
              colarr.push(j);
            }
          }
        }

        colarr.forEach((element) => {
          colors[element] = [];
        });

        s.graph.nodes().forEach((element) => {
          colorsTable.push(ct);
          ct++;
        });
        var visCol = [];

        colarr.forEach((e) => {
          dict[`n${e}`].forEach((element) => {
            if (colorsTable.includes(colors[parseInt(element)])) {
              visCol.push(colors[parseInt(element)]);
            }
          });
          var arr3 = colorsTable.filter(function (obj) {
            return visCol.indexOf(obj) == -1;
          });
          colors[e] = arr3[0];
          visCol = [];
        });
        console.log("Kolory od ostatniego:");
        console.log(colarr);
        console.log(colors);

        s.kill();

        // Random kolor
        s = new sigma({
          graph: g,
        });
        var dict = new Object();
        s.graph.nodes().forEach((element) => {
          dict[element.id] = [];
        });
        s.graph.edges().forEach((element) => {
          dict[element.source].push(element.target.slice(1, 2));
          dict[element.target].push(element.source.slice(1, 2));
        });
        colors = new Object();
        colorsTable = [];
        ct = 0;
        colarr = [];
        s.graph.nodes().forEach((element) => {
          colarr.push(parseInt(element.id.slice(1, 2)));
        });

        function shuffle(array) {
          var currentIndex = array.length,
            temporaryValue,
            randomIndex;

          // While there remain elements to shuffle...
          while (0 !== currentIndex) {
            // Pick a remaining element...
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;

            // And swap it with the current element.
            temporaryValue = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temporaryValue;
          }

          return array;
        }

        colarr = shuffle(colarr);

        colarr.forEach((element) => {
          colors[element] = [];
        });

        s.graph.nodes().forEach((element) => {
          colorsTable.push(ct);
          ct++;
        });
        var visCol = [];

        colarr.forEach((e) => {
          dict[`n${e}`].forEach((element) => {
            if (colorsTable.includes(colors[parseInt(element)])) {
              visCol.push(colors[parseInt(element)]);
            }
          });
          var arr3 = colorsTable.filter(function (obj) {
            return visCol.indexOf(obj) == -1;
          });
          colors[e] = arr3[0];
          visCol = [];
        });
        console.log("Kolory random:");
        console.log(colarr);
        console.log(colors);

        s.kill();

        // HAMILTON
        s = new sigma({
          graph: g,
        });
        if (spj) {
          var dict = new Object();
          visited = [];
          s.graph.nodes().forEach((element) => {
            dict[element.id] = [];
          });
          s.graph.edges().forEach((element) => {
            dict[element.source].push(element.target);
            dict[element.target].push(element.source);
          });
          hamilton = [];
          dead = new Object();
          s.graph.nodes().forEach((element) => {
            dead[parseInt(element.id.slice(1, 2))] = [];
          });
          visited.push(s.graph.nodes()[0].id);
          for (let i = 0; i < s.graph.nodes().length; i++) {
            hamilton.push(0);
          }

          ham(1, dict, hamilton, dead);

          if (hamilton[0] == 0 && hamilton[1] == 0) {
            document.querySelector(
              "#hamilton-container"
            ).innerHTML = `Brak cyklu hamiltona`;
          } else {
            document.querySelector(
              "#hamilton-container"
            ).innerHTML = `hamilton:${hamilton}`;
          }
        }
        // EULER
        s.kill();

        s = new sigma({
          graph: g,
          renderer: {
            container: "sigma-container",
            type: "canvas",
          },
          settings: {
            edgeLabelSize: "proportional",
            defaultLabelSize: 20,
            defaultEdgeLabelSize: 20,
          },
        });
        if (spj) {
          var eul = true;
          s.graph.nodes().forEach((e) => {
            if (s.graph.degree(e.id) % 2 !== 0) {
              eul = false;
            }
          });
          if (eul === false) {
            document.querySelector(
              "#euler-container"
            ).innerHTML = `Euler: Brak`;
          } else {
            var dict = new Object();
            visited = [];
            stos = [];
            s.graph.nodes().forEach((element) => {
              dict[element.id] = [];
            });
            s.graph.edges().forEach((element) => {
              dict[element.source].push(element.target);
              dict[element.target].push(element.source);
            });
            visited.push(s.graph.nodes()[0].id);
            dfs(s.graph.nodes()[0].id, dict, visited, stos);
            document.querySelector(
              "#euler-container"
            ).innerHTML = `Euler:${stos}`;
          }
        } else {
          document.querySelector(
            "#hamilton-container"
          ).innerHTML = `Cykl nie jest spojny`;
        }
        s.kill();
        s = new sigma({
          graph: g,
          renderer: {
            container: "sigma-container",
            type: "canvas",
          },
          settings: {
            edgeLabelSize: "proportional",
            defaultLabelSize: 20,
            defaultEdgeLabelSize: 20,
          },
        });
      }
      function MacS() {
        var i,
          g = {
            nodes: [],
            edges: [],
          };
        var z = 0;
        var m3str = document.querySelector("#m3").value;
        var res = m3str.split(";");
        var table = [];

        res.forEach((e) => {
          table.push(e.split(":"));
        });
        for (let i = 0; i < table.length; i++) {
          var res1 = table[i][1].split(",");

          for (let j = 0; j < res1.length; j++) {
            if (table[i][0] <= res1[j]) {
              g.edges.push({
                id: "e" + z,
                source: "n" + table[i][0],
                target: "n" + res1[j],
                size: 1,
                label: "E" + z,
                type: "curve",
                count: z,
              });
              z++;
            }
          }
        }
        s.kill();
        var N = res.length;
        var E = 0;

        for (i = 0; i < N; i++)
          g.nodes.push({
            id: "n" + i,
            label: "W" + i,
            x: Math.random(),
            y: Math.random(),
            size: 1,
            color: "#666",
          });

        s = new sigma({
          graph: g,
          renderer: {
            container: "sigma-container",
            type: "canvas",
          },
          settings: {
            edgeLabelSize: "proportional",
            defaultLabelSize: 15,
            defaultEdgeLabelSize: 15,
          },
        });
        var visited = [];
        var stos = [];
        spj = false;
        // SPOJNOSC
        var dict = new Object();
        s.graph.nodes().forEach((element) => {
          dict[element.id] = [];
        });
        s.graph.edges().forEach((element) => {
          dict[element.source].push(element.target);
          dict[element.target].push(element.source);
        });

        visited.push(s.graph.nodes()[0].id);
        spj = spoj(s.graph.nodes()[0].id, dict, visited, stos);
        document.querySelector("#dfs-container").innerHTML = `dfs: ${stos}`;
        // KRAWEDZ KRYTYCZNA

        s.kill();
        critable = [];

        s = new sigma({
          graph: g,
        });

        for (let i = 0; i < s.graph.edges().length; i++) {
          s.kill();
          s = new sigma({
            graph: g,
          });
          s.graph.dropEdge(s.graph.edges()[i].id);
          var visited = [];
          var stos = [];
          var dict = new Object();
          s.graph.nodes().forEach((element) => {
            dict[element.id] = [];
          });
          s.graph.edges().forEach((element) => {
            dict[element.source].push(element.target);
            dict[element.target].push(element.source);
          });
          visited.push(s.graph.nodes()[0].id);

          crit = spoj(s.graph.nodes()[0].id, dict, visited, stos);
          if (!crit) {
            critable.push(i);
          }
          s = new sigma({
            graph: g,
          });
        }

        document.querySelector(
          "#crit-container"
        ).innerHTML = `krytyczna ${critable.toString()}`;

        s.kill();

        // KOLOROWANIE
        s = new sigma({
          graph: g,
        });
        var dict = new Object();
        s.graph.nodes().forEach((element) => {
          dict[element.id] = [];
        });
        s.graph.edges().forEach((element) => {
          dict[element.source].push(element.target.slice(1, 2));
          dict[element.target].push(element.source.slice(1, 2));
        });
        colors = new Object();
        colorsTable = [];
        ct = 0;
        s.graph.nodes().forEach((element) => {
          colors[parseInt(element.id.slice(1, 2))] = [];
        });
        s.graph.nodes().forEach((element) => {
          colorsTable.push(ct);
          ct++;
        });

        colors[0] = 0;
        var visCol = [];
        for (let i = 1; i < s.graph.nodes().length; i++) {
          dict[`n${i}`].forEach((e) => {
            if (colorsTable.includes(colors[parseInt(e)])) {
              visCol.push(colors[parseInt(e)]);
            }
          });
          var arr3 = colorsTable.filter(function (obj) {
            return visCol.indexOf(obj) == -1;
          });
          colors[i] = arr3[0];
          visCol = [];
        }

        document.querySelector(
          "#color-container"
        ).innerHTML = `Kolor${JSON.stringify(colors)}`;

        s.kill();

        // Kolor last
        s = new sigma({
          graph: g,
        });
        var dict = new Object();
        s.graph.nodes().forEach((element) => {
          dict[element.id] = [];
        });
        s.graph.edges().forEach((element) => {
          dict[element.source].push(element.target.slice(1, 2));
          dict[element.target].push(element.source.slice(1, 2));
        });
        colarr = [];
        console.log(dict);
        for (let i = s.graph.nodes().length - 1; i > -1; i--) {
          dict[`n${i}`];
          for (let j = 0; j < s.graph.nodes().length; j++) {
            if (dict[`n${j}`].length == i) {
              colarr.push(j);
            }
          }
        }

        colarr.forEach((element) => {
          colors[element] = [];
        });

        s.graph.nodes().forEach((element) => {
          colorsTable.push(ct);
          ct++;
        });
        var visCol = [];

        colarr.forEach((e) => {
          dict[`n${e}`].forEach((element) => {
            if (colorsTable.includes(colors[parseInt(element)])) {
              visCol.push(colors[parseInt(element)]);
            }
          });
          var arr3 = colorsTable.filter(function (obj) {
            return visCol.indexOf(obj) == -1;
          });
          colors[e] = arr3[0];
          visCol = [];
        });
        console.log("Kolory od ostatniego:");
        console.log(colarr);
        console.log(colors);

        s.kill();

        // Random kolor
        s = new sigma({
          graph: g,
        });
        var dict = new Object();
        s.graph.nodes().forEach((element) => {
          dict[element.id] = [];
        });
        s.graph.edges().forEach((element) => {
          dict[element.source].push(element.target.slice(1, 2));
          dict[element.target].push(element.source.slice(1, 2));
        });
        colors = new Object();
        colorsTable = [];
        ct = 0;
        colarr = [];
        s.graph.nodes().forEach((element) => {
          colarr.push(parseInt(element.id.slice(1, 2)));
        });

        function shuffle(array) {
          var currentIndex = array.length,
            temporaryValue,
            randomIndex;

          // While there remain elements to shuffle...
          while (0 !== currentIndex) {
            // Pick a remaining element...
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;

            // And swap it with the current element.
            temporaryValue = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temporaryValue;
          }

          return array;
        }

        colarr = shuffle(colarr);

        colarr.forEach((element) => {
          colors[element] = [];
        });

        s.graph.nodes().forEach((element) => {
          colorsTable.push(ct);
          ct++;
        });
        var visCol = [];

        colarr.forEach((e) => {
          dict[`n${e}`].forEach((element) => {
            if (colorsTable.includes(colors[parseInt(element)])) {
              visCol.push(colors[parseInt(element)]);
            }
          });
          var arr3 = colorsTable.filter(function (obj) {
            return visCol.indexOf(obj) == -1;
          });
          colors[e] = arr3[0];
          visCol = [];
        });
        console.log("Kolory random:");
        console.log(colarr);
        console.log(colors);

        s.kill();

        // HAMILTON
        s = new sigma({
          graph: g,
        });
        if (spj) {
          var dict = new Object();
          visited = [];
          s.graph.nodes().forEach((element) => {
            dict[element.id] = [];
          });
          s.graph.edges().forEach((element) => {
            dict[element.source].push(element.target);
            dict[element.target].push(element.source);
          });
          hamilton = [];
          dead = new Object();
          s.graph.nodes().forEach((element) => {
            dead[parseInt(element.id.slice(1, 2))] = [];
          });
          visited.push(s.graph.nodes()[0].id);
          for (let i = 0; i < s.graph.nodes().length; i++) {
            hamilton.push(0);
          }

          ham(1, dict, hamilton, dead);

          if (hamilton[0] == 0 && hamilton[1] == 0) {
            document.querySelector(
              "#hamilton-container"
            ).innerHTML = `Brak cyklu hamiltona`;
          } else {
            document.querySelector(
              "#hamilton-container"
            ).innerHTML = `hamilton:${hamilton}`;
          }
        }
        // EULER
        s.kill();

        s = new sigma({
          graph: g,
          renderer: {
            container: "sigma-container",
            type: "canvas",
          },
          settings: {
            edgeLabelSize: "proportional",
            defaultLabelSize: 20,
            defaultEdgeLabelSize: 20,
          },
        });
        if (spj) {
          var eul = true;
          s.graph.nodes().forEach((e) => {
            if (s.graph.degree(e.id) % 2 !== 0) {
              eul = false;
            }
          });
          if (eul === false) {
            document.querySelector(
              "#euler-container"
            ).innerHTML = `Euler: Brak`;
          } else {
            var dict = new Object();
            visited = [];
            stos = [];
            s.graph.nodes().forEach((element) => {
              dict[element.id] = [];
            });
            s.graph.edges().forEach((element) => {
              dict[element.source].push(element.target);
              dict[element.target].push(element.source);
            });
            visited.push(s.graph.nodes()[0].id);
            dfs(s.graph.nodes()[0].id, dict, visited, stos);
            document.querySelector(
              "#euler-container"
            ).innerHTML = `Euler:${stos}`;
          }
        } else {
          document.querySelector(
            "#hamilton-container"
          ).innerHTML = `Cykl nie jest spojny`;
        }
        s.kill();
        s = new sigma({
          graph: g,
          renderer: {
            container: "sigma-container",
            type: "canvas",
          },
          settings: {
            edgeLabelSize: "proportional",
            defaultLabelSize: 20,
            defaultEdgeLabelSize: 20,
          },
        });
      }

      function ham(w, dict, hamilton, dead) {
        if (w == 0) {
          return false;
        }
        if (w == hamilton.length) {
          w = hamilton.length - 1;
        }
        for (let i = hamilton[w]; i < hamilton.length; i++) {
          if (dict[`n${hamilton[hamilton.length - 1]}`].includes("n0")) {
            return true;
            break;
          }
          if (
            !hamilton.includes(i) &&
            dict[`n${hamilton[w - 1]}`].includes(`n${i}`) &&
            !dead[w].includes(i)
          ) {
            hamilton[w] = i;
            ham(w + 1, dict, hamilton, dead);
          } else if (i == hamilton.length - 1) {
            dead[w - 1].push(hamilton[w - 1]);
            hamilton[w] = 0;
            if (hamilton[w - 1] == hamilton.length - 1) {
              hamilton[w - 1] = 0;
            }
            ham(w - 1, dict, hamilton, dead);
          }
        }
      }
      function spoj(w, dict, visited, stos) {
        if (dict[w].length !== 0) {
          var arrS = dict[w].filter(function (obj) {
            return visited.indexOf(obj) == -1;
          });
          arr3 = arrS.filter(function (obj) {
            return stos.indexOf(obj) == -1;
          });
          if (arr3.length !== 0) {
            for (let i = 0; i < s.graph.edges().length; i++) {
              if (
                s.graph.edges()[i].source === w &&
                s.graph.edges()[i].target === arr3[0]
              ) {
                const index = dict[w].indexOf(arr3[0]);
                if (index > -1) {
                  dict[w].splice(index, 1);
                }

                const indexx = dict[arr3[0]].indexOf(w);
                if (index > -1) {
                  dict[arr3[0]].splice(indexx, 1);
                }
                visited.push(arr3[0]);

                s.graph.dropEdge(s.graph.edges()[i].id);

                spoj(arr3[0], dict, visited, stos);
              } else if (
                s.graph.edges()[i].source === arr3[0] &&
                s.graph.edges()[i].target === w
              ) {
                const index = dict[w].indexOf(arr3[0]);
                if (index > -1) {
                  dict[w].splice(index, 1);
                }
                const indexx = dict[arr3[0]].indexOf(w);
                if (index > -1) {
                  dict[arr3[0]].splice(indexx, 1);
                }
                visited.push(arr3[0]);

                s.graph.dropEdge(s.graph.edges()[i].id);

                spoj(arr3[0], dict, visited, stos);
              }
            }
          } else {
            var popped = visited.pop();
            if (popped !== undefined) {
              stos.push(popped);
              spoj(popped, dict, visited, stos);
            }
          }
        } else {
          var popped = visited.pop();
          if (popped !== undefined) {
            stos.push(popped);
            if (dict[popped].length != 0) {
              stos.pop();
              visited.push(popped);
            }
            spoj(popped, dict, visited, stos);
          }
        }
        if (stos.length === s.graph.nodes().length) {
          return true;
        }
      }
      function dfs(w, dict, visited, stos) {
        if (dict[w].length !== 0) {
          var arr3 = dict[w].filter(function (obj) {
            return visited.indexOf(obj) == -1;
          });

          if (arr3.length !== 0) {
            for (let i = 0; i < s.graph.edges().length; i++) {
              var arrnum = [];
              arr3.forEach((element) => {
                arrnum.push(element.slice(1, 2));
              });
              arrnum.sort(function (a, b) {
                return a - b;
              });
              most = true;
              while (most) {
                for (let i = 0; i < arrnum.length; i++) {
                  if (dict[`n${arrnum[i]}`].length > 1) {
                    most = false;
                    var mini = `n${arrnum[i]}`;
                    break;
                  } else {
                    var mini = `n${arrnum[i]}`;
                  }
                }
                most = false;
              }

              if (
                s.graph.edges()[i].source === w &&
                s.graph.edges()[i].target == mini
              ) {
                const index = dict[w].indexOf(mini);
                if (index > -1) {
                  dict[w].splice(index, 1);
                }

                const indexx = dict[mini].indexOf(w);
                if (index > -1) {
                  dict[mini].splice(indexx, 1);
                }
                visited.push(mini);

                s.graph.dropEdge(s.graph.edges()[i].id);

                dfs(mini, dict, visited, stos);
              } else if (
                s.graph.edges()[i].source === mini &&
                s.graph.edges()[i].target === w
              ) {
                const index = dict[w].indexOf(mini);
                if (index > -1) {
                  dict[w].splice(index, 1);
                }
                const indexx = dict[mini].indexOf(w);
                if (index > -1) {
                  dict[mini].splice(indexx, 1);
                }
                visited.push(mini);

                s.graph.dropEdge(s.graph.edges()[i].id);

                dfs(mini, dict, visited, stos);
              }
            }
          } else {
            var arrnum = [];
            dict[w].forEach((element) => {
              arrnum.push(element.slice(1, 2));
            });
            arrnum.sort(function (a, b) {
              return a - b;
            });
            most = true;
            while (most) {
              for (let i = 0; i < arrnum.length; i++) {
                if (dict[`n${arrnum[i]}`].length > 1) {
                  most = false;
                  var minz = `n${arrnum[i]}`;
                  break;
                } else {
                  var minz = `n${arrnum[i]}`;
                }
              }
              most = false;
            }

            for (let i = 0; i < s.graph.edges().length; i++) {
              if (
                s.graph.edges()[i].source === w &&
                s.graph.edges()[i].target === minz
              ) {
                const index = dict[w].indexOf(minz);
                if (index > -1) {
                  dict[w].splice(index, 1);
                }

                const indexx = dict[minz].indexOf(w);
                if (index > -1) {
                  dict[minz].splice(indexx, 1);
                }
                pops = minz;
                visited.push(minz);
                s.graph.dropEdge(s.graph.edges()[i].id);
                dfs(pops, dict, visited, stos);
              } else if (
                s.graph.edges()[i].source === minz &&
                s.graph.edges()[i].target === w
              ) {
                const index = dict[w].indexOf(minz);
                if (index > -1) {
                  dict[w].splice(index, 1);
                }

                const indexx = dict[minz].indexOf(w);
                if (index > -1) {
                  dict[minz].splice(indexx, 1);
                }
                pops = minz;
                visited.push(minz);
                s.graph.dropEdge(s.graph.edges()[i].id);
                dfs(pops, dict, visited, stos);
              }
            }
          }
        } else {
          var popped = visited.pop();

          if (popped !== undefined) {
            stos.push(popped);
            if (dict[popped].length != 0) {
              stos.pop();
              visited.push(popped);
            }
            dfs(popped, dict, visited, stos);
          }
        }
      }
    </script>
  </body>
</html>
